-- =====================================================
-- SNOWFLAKE STREAMING TABLES SETUP
-- =====================================================
USE ROLE ACCOUNTADMIN;
USE DATABASE SWIGGY;
USE SCHEMA SILVER;
USE WAREHOUSE ADHOC_WH;

-- =====================================================
-- SILVER LAYER - STREAM TABLES
-- =====================================================

-- 1. ORDERS STREAM TABLE
CREATE OR REPLACE TABLE SILVER.ORDERS_STREAM_SLV (
    -- Kafka metadata
    RECORD_METADATA VARIANT,              -- Snowflake connector auto-populates this
    RECORD_CONTENT VARIANT,               -- Raw JSON from Kafka message
    
    -- Extracted fields (computed columns)
    KAFKA_OFFSET NUMBER AS (RECORD_METADATA:offset::NUMBER),
    KAFKA_PARTITION NUMBER AS (RECORD_METADATA:partition::NUMBER),
    KAFKA_TIMESTAMP TIMESTAMP_NTZ(9) AS (TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3)),

    EVENT_TYPE VARCHAR(50) AS (RECORD_CONTENT:event_type::VARCHAR),
    EVENT_TIMESTAMP TIMESTAMP_TZ  AS (TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING)),

    -- ACTUAL ORDER DATA
    ORDER_ID INTEGER AS (RECORD_CONTENT:order_id::INTEGER),
    CUSTOMER_ID INTEGER AS (RECORD_CONTENT:customer_id::INTEGER),
    RESTAURANT_ID INTEGER AS (RECORD_CONTENT:restaurant_id::INTEGER),
    ORDER_DATE TIMESTAMP_TZ AS (RECORD_CONTENT:order_date::TIMESTAMP_TZ),
    TOTAL_AMOUNT NUMBER(10, 2) AS (RECORD_CONTENT:total_amount::NUMBER(10,2)),
    STATUS VARCHAR(50) AS (RECORD_CONTENT:status::VARCHAR),
    PAYMENT_METHOD VARCHAR(50) AS (RECORD_CONTENT:payment_method::VARCHAR),
    
    -- Processing flags
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time order events from Kafka';

-- Add clustering for better query performance
-- ALTER TABLE SILVER.ORDERS_STREAM_SLV
-- CLUSTER BY (ORDER_ID, INGESTED_AT);


-- 2. ORDER ITEMS STREAM TABLE
CREATE OR REPLACE TABLE SILVER.ORDER_ITEMS_STREAM_SLV (
    -- Kafka metadata
    RECORD_METADATA VARIANT,
    RECORD_CONTENT VARIANT,
    
    -- Extracted fields
    KAFKA_OFFSET NUMBER AS (RECORD_METADATA:offset::NUMBER),
    KAFKA_PARTITION NUMBER AS (RECORD_METADATA:partition::NUMBER),
    KAFKA_TIMESTAMP TIMESTAMP_NTZ(9) AS (TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3)),
    
    EVENT_TYPE VARCHAR(50) AS (RECORD_CONTENT:event_type::VARCHAR),
    EVENT_TIMESTAMP TIMESTAMP_TZ  AS (TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING)),

    -- ACTUAL ORDER ITEM DATA
    ORDER_ITEM_ID INTEGER AS (RECORD_CONTENT:order_item_id::INTEGER),
    ORDER_ID INTEGER AS (RECORD_CONTENT:order_id::INTEGER),
    MENU_ID INTEGER AS (RECORD_CONTENT:menu_id::INTEGER),
    QUANTITY INTEGER AS (RECORD_CONTENT:quantity::INTEGER),
    PRICE NUMBER(10, 2) AS (RECORD_CONTENT:price::NUMBER(10,2)),
    SUBTOTAL NUMBER(10, 2) AS (RECORD_CONTENT:subtotal::NUMBER(10,2)),
    
    -- Processing flags
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time order item events from Kafka';

-- ALTER TABLE SILVER.ORDER_ITEMS_STREAM_SLV
-- CLUSTER BY (ORDER_ID, INGESTED_AT);

-- 3. DELIVERY STREAM TABLE
CREATE OR REPLACE TABLE SILVER.DELIVERY_STREAM_SLV (
    -- Kafka metadata
    RECORD_METADATA VARIANT,
    RECORD_CONTENT VARIANT,
    
    -- Extracted fields
    KAFKA_OFFSET NUMBER AS (RECORD_METADATA:offset::NUMBER),
    KAFKA_PARTITION NUMBER AS (RECORD_METADATA:partition::NUMBER),
    KAFKA_TIMESTAMP TIMESTAMP_NTZ(9) AS (TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3)),
    
    EVENT_TYPE VARCHAR(50) AS (RECORD_CONTENT:event_type::VARCHAR),
    EVENT_TIMESTAMP TIMESTAMP_TZ  AS (TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING)),

    -- ACTUAL DELIVERY DATA
    DELIVERY_ID INTEGER AS (RECORD_CONTENT:delivery_id::INTEGER),
    ORDER_ID INTEGER AS (RECORD_CONTENT:order_id::INTEGER),
    DELIVERY_AGENT_ID INTEGER AS (RECORD_CONTENT:delivery_agent_id::INTEGER),
    DELIVERY_STATUS VARCHAR(50) AS (RECORD_CONTENT:delivery_status::VARCHAR),
    ESTIMATED_TIME TIMESTAMP_TZ AS (RECORD_CONTENT:estimated_time::TIMESTAMP_TZ),
    CUSTOMER_ADDRESS_ID INTEGER AS (RECORD_CONTENT:customer_address_id::INTEGER),
    DELIVERY_DATE TIMESTAMP_TZ AS (RECORD_CONTENT:delivery_date::TIMESTAMP_TZ),
    LOCATION VARIANT AS (RECORD_CONTENT:location::VARIANT),
    
    -- Processing flags
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time delivery events from Kafka';

-- ALTER TABLE SILVER.DELIVERY_STREAM_SLV
-- CLUSTER BY (ORDER_ID, DELIVERY_ID, INGESTED_AT);

-- =====================================================
-- CREATE SNOWFLAKE STREAMS (CDC)
-- =====================================================

-- Stream for Orders
CREATE OR REPLACE STREAM STREAM_ORDERS_CHANGES 
ON TABLE SILVER.ORDERS_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new order records for Gold layer processing';

-- Stream for Order Items
CREATE OR REPLACE STREAM STREAM_ORDER_ITEMS_CHANGES 
ON TABLE SILVER.ORDER_ITEMS_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new order item records for Gold layer processing';

-- Stream for Delivery
CREATE OR REPLACE STREAM STREAM_DELIVERY_CHANGES 
ON TABLE SILVER.DELIVERY_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new delivery records for Gold layer processing';

-- =====================================================
-- GRANT PERMISSIONS TO KAFKA ROLE
-- =====================================================

GRANT SELECT, INSERT ON TABLE SILVER.ORDERS_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;
GRANT SELECT, INSERT ON TABLE SILVER.ORDER_ITEMS_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;
GRANT SELECT, INSERT ON TABLE SILVER.DELIVERY_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;

-- =====================================================
-- VERIFY SETUP
-- =====================================================

-- Check tables
SHOW TABLES LIKE '%STREAM%' IN SCHEMA SILVER;

-- Check streams
SHOW STREAMS IN SCHEMA SILVER;

-- View table structure
DESC TABLE SILVER.ORDERS_STREAM_SLV;
DESC TABLE SILVER.ORDER_ITEMS_STREAM_SLV;
DESC TABLE SILVER.DELIVERY_STREAM_SLV;

-- =====================================================
-- STREAMING PROCEDURES - SILVER TO GOLD
-- =====================================================
USE ROLE ACCOUNTADMIN;
USE DATABASE SWIGGY;
USE WAREHOUSE ADHOC_WH;

-- =====================================================
-- PROCEDURE 1: ORDERS STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_ORDERS_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_ROWS_UPDATED INTEGER;
    V_ROWS_PROCESSED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();
    
    -- Check if stream has data
    IF (SYSTEM$STREAM_HAS_DATA('STREAM_ORDERS_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;
    
    -- Process orders from stream
    MERGE INTO GOLD.FACT_ORDER AS TGT
    USING (
        SELECT 
            ORDER_ID,
            CUSTOMER_ID,
            RESTAURANT_ID,
            ORDER_DATE,
            TOTAL_AMOUNT,
            STATUS,
            PAYMENT_METHOD,
            EVENT_TIMESTAMP,
            EVENT_TYPE
        FROM STREAM_ORDERS_CHANGES
        WHERE ORDER_ID IS NOT NULL
          AND EVENT_TYPE IN ('ORDER_CREATED', 'ORDER_UPDATED')
    ) AS SRC
    ON TGT.ORDER_ID = SRC.ORDER_ID
    
    -- Update existing orders (status changes)
    WHEN MATCHED AND TGT.CURRENT_STATUS != SRC.STATUS THEN
        UPDATE SET
            CURRENT_STATUS = SRC.STATUS,
            TOTAL_AMOUNT = SRC.TOTAL_AMOUNT,
            STATUS_UPDATED_AT = SRC.EVENT_TIMESTAMP,
            BATCH_ID = :V_BATCH_ID
    
    -- Insert new orders
    WHEN NOT MATCHED THEN
        INSERT (
            ORDER_ID, CUSTOMER_ID, RESTAURANT_ID, ORDER_DATE,
            TOTAL_AMOUNT, CURRENT_STATUS, INITIAL_STATUS,
            PAYMENT_METHOD, STATUS_UPDATED_AT, BATCH_ID, CREATED_AT
        )
        VALUES (
            SRC.ORDER_ID, SRC.CUSTOMER_ID, SRC.RESTAURANT_ID,
            SRC.ORDER_DATE, SRC.TOTAL_AMOUNT, SRC.STATUS, SRC.STATUS,
            SRC.PAYMENT_METHOD, SRC.EVENT_TIMESTAMP, :V_BATCH_ID,
            CURRENT_TIMESTAMP()
        );
    
    V_ROWS_PROCESSED := SQLROWCOUNT;
    
    -- Log status changes to history
    INSERT INTO GOLD.FACT_ORDER_STATUS_HISTORY (
        ORDER_ID, OLD_STATUS, NEW_STATUS, STATUS_CHANGED_AT, BATCH_ID
    )
    SELECT 
        TGT.ORDER_ID,
        TGT.CURRENT_STATUS AS OLD_STATUS,
        SRC.STATUS AS NEW_STATUS,
        SRC.EVENT_TIMESTAMP,
        :V_BATCH_ID
    FROM STREAM_ORDERS_CHANGES SRC
    INNER JOIN GOLD.FACT_ORDER TGT ON TGT.ORDER_ID = SRC.ORDER_ID
    WHERE TGT.CURRENT_STATUS != SRC.STATUS
      AND SRC.EVENT_TYPE = 'ORDER_UPDATED';
    
    -- Mark stream records as processed
    UPDATE SILVER.ORDERS_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE ORDER_ID IN (
        SELECT ORDER_ID FROM STREAM_ORDERS_CHANGES
    );
    
    V_END_TIME := CURRENT_TIMESTAMP();
    
    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_PROCESSED', V_ROWS_PROCESSED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );
    
EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- PROCEDURE 2: ORDER ITEMS STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_ORDER_ITEMS_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();
    
    IF (SYSTEM$STREAM_HAS_DATA('STREAM_ORDER_ITEMS_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;
    
    -- Insert new order items (append-only)
    INSERT INTO GOLD.FACT_ORDER_ITEM (
        ORDER_ITEM_ID, ORDER_ID, MENU_ID, QUANTITY, 
        PRICE, SUBTOTAL, ORDER_TIMESTAMP, BATCH_ID, CREATED_AT
    )
    SELECT
        ORDER_ITEM_ID,
        ORDER_ID,
        MENU_ID,
        QUANTITY,
        PRICE,
        SUBTOTAL,
        EVENT_TIMESTAMP,
        :V_BATCH_ID,
        CURRENT_TIMESTAMP()
    FROM STREAM_ORDER_ITEMS_CHANGES
    WHERE ORDER_ITEM_ID IS NOT NULL
      AND EVENT_TYPE = 'ITEM_ADDED'
      AND NOT EXISTS (
          SELECT 1 FROM GOLD.FACT_ORDER_ITEM TGT
          WHERE TGT.ORDER_ITEM_ID = STREAM_ORDER_ITEMS_CHANGES.ORDER_ITEM_ID
      );
    
    V_ROWS_INSERTED := SQLROWCOUNT;
    
    -- Mark as processed
    UPDATE SILVER.ORDER_ITEMS_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE ORDER_ITEM_ID IN (
        SELECT ORDER_ITEM_ID FROM STREAM_ORDER_ITEMS_CHANGES
    );
    
    V_END_TIME := CURRENT_TIMESTAMP();
    
    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_INSERTED', V_ROWS_INSERTED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );
    
EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- PROCEDURE 3: DELIVERY STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_DELIVERY_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_ROWS_UPDATED INTEGER;
    V_ROWS_PROCESSED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();
    
    IF (SYSTEM$STREAM_HAS_DATA('STREAM_DELIVERY_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;
    
    -- Process delivery events
    MERGE INTO GOLD.FACT_DELIVERY AS TGT
    USING (
        SELECT 
            DELIVERY_ID,
            ORDER_ID,
            DELIVERY_AGENT_ID,
            CUSTOMER_ADDRESS_ID,
            DELIVERY_STATUS,
            ESTIMATED_TIME,
            DELIVERY_DATE,
            EVENT_TIMESTAMP,
            EVENT_TYPE
        FROM STREAM_DELIVERY_CHANGES
        WHERE DELIVERY_ID IS NOT NULL
    ) AS SRC
    ON TGT.DELIVERY_ID = SRC.DELIVERY_ID
    
    -- Update delivery status
    WHEN MATCHED AND TGT.CURRENT_STATUS != SRC.DELIVERY_STATUS THEN
        UPDATE SET
            CURRENT_STATUS = SRC.DELIVERY_STATUS,
            DELIVERY_DATE = SRC.DELIVERY_DATE,
            STATUS_UPDATED_AT = SRC.EVENT_TIMESTAMP,
            BATCH_ID = :V_BATCH_ID
    
    -- Insert new delivery
    WHEN NOT MATCHED THEN
        INSERT (
            DELIVERY_ID, ORDER_ID, DELIVERY_AGENT_ID, CUSTOMER_ADDRESS_ID,
            CURRENT_STATUS, INITIAL_STATUS, ESTIMATED_TIME, DELIVERY_DATE,
            STATUS_UPDATED_AT, BATCH_ID, CREATED_AT
        )
        VALUES (
            SRC.DELIVERY_ID, SRC.ORDER_ID, SRC.DELIVERY_AGENT_ID,
            SRC.CUSTOMER_ADDRESS_ID, SRC.DELIVERY_STATUS, SRC.DELIVERY_STATUS,
            SRC.ESTIMATED_TIME, SRC.DELIVERY_DATE, SRC.EVENT_TIMESTAMP,
            :V_BATCH_ID, CURRENT_TIMESTAMP()
        );
    
    V_ROWS_PROCESSED := SQLROWCOUNT;
    
    -- Log status changes
    INSERT INTO GOLD.FACT_DELIVERY_STATUS_HISTORY (
        DELIVERY_ID, OLD_STATUS, NEW_STATUS, STATUS_CHANGED_AT, BATCH_ID
    )
    SELECT 
        TGT.DELIVERY_ID,
        TGT.CURRENT_STATUS AS OLD_STATUS,
        SRC.DELIVERY_STATUS AS NEW_STATUS,
        SRC.EVENT_TIMESTAMP,
        :V_BATCH_ID
    FROM STREAM_DELIVERY_CHANGES SRC
    INNER JOIN GOLD.FACT_DELIVERY TGT ON TGT.DELIVERY_ID = SRC.DELIVERY_ID
    WHERE TGT.CURRENT_STATUS != SRC.DELIVERY_STATUS
      AND SRC.EVENT_TYPE = 'STATUS_UPDATED';
    
    -- Mark as processed
    UPDATE SILVER.DELIVERY_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE DELIVERY_ID IN (
        SELECT DELIVERY_ID FROM STREAM_DELIVERY_CHANGES
    );
    
    V_END_TIME := CURRENT_TIMESTAMP();
    
    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_PROCESSED', V_ROWS_PROCESSED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );
    
EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- CREATE SNOWFLAKE TASKS
-- =====================================================

-- Task for Orders (every 5 minutes)
CREATE OR REPLACE TASK GOLD.TASK_ORDERS_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '5 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('STREAM_ORDERS_CHANGES')
AS
CALL GOLD.SP_ORDERS_STREAM_TO_GOLD();

-- Task for Order Items (every 5 minutes)
CREATE OR REPLACE TASK GOLD.TASK_ORDER_ITEMS_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '5 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('STREAM_ORDER_ITEMS_CHANGES')
AS
CALL GOLD.SP_ORDER_ITEMS_STREAM_TO_GOLD();

-- Task for Delivery (every 2 minutes - more frequent)
CREATE OR REPLACE TASK GOLD.TASK_DELIVERY_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '2 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('STREAM_DELIVERY_CHANGES')
AS
CALL GOLD.SP_DELIVERY_STREAM_TO_GOLD();

-- Resume all tasks
ALTER TASK GOLD.TASK_ORDERS_STREAM_TO_GOLD RESUME;
ALTER TASK GOLD.TASK_ORDER_ITEMS_STREAM_TO_GOLD RESUME;
ALTER TASK GOLD.TASK_DELIVERY_STREAM_TO_GOLD RESUME;

-- DROP TASK GOLD.TASK_ORDERS_STREAM_TO_GOLD;
-- DROP TASK GOLD.TASK_ORDER_ITEMS_STREAM_TO_GOLD;
-- DROP TASK GOLD.TASK_DELIVERY_STREAM_TO_GOLD;
-- =====================================================



