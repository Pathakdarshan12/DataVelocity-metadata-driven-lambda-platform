-- =====================================================
-- SNOWFLAKE STREAMING TABLES SETUP FOR SNOWPIPE STREAMING
-- =====================================================
USE ROLE ACCOUNTADMIN;
USE DATABASE SWIGGY;
USE SCHEMA SILVER;
USE WAREHOUSE ADHOC_WH;

-- =====================================================
-- SILVER LAYER - STREAM TABLES (NO COMPUTED COLUMNS)
-- =====================================================

-- 1. ORDERS STREAM TABLE
CREATE OR REPLACE TABLE SILVER.ORDERS_STREAM_SLV (
    -- Kafka metadata (raw storage only)
    RECORD_METADATA VARIANT,
    RECORD_CONTENT VARIANT,

    -- Processing flags (no default values)
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time order events from Kafka';

-- 2. ORDER ITEMS STREAM TABLE
CREATE OR REPLACE TABLE SILVER.ORDER_ITEMS_STREAM_SLV (
    -- Kafka metadata (raw storage only)
    RECORD_METADATA VARIANT,
    RECORD_CONTENT VARIANT,

    -- Processing flags (no default values)
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time order item events from Kafka';

-- 3. DELIVERY STREAM TABLE
CREATE OR REPLACE TABLE SILVER.DELIVERY_STREAM_SLV (
    -- Kafka metadata (raw storage only)
    RECORD_METADATA VARIANT,
    RECORD_CONTENT VARIANT,
    INGESTED_AT TIMESTAMP_TZ,
    PROCESSED_TO_GOLD BOOLEAN,
    BATCH_ID VARCHAR(36)
)
COMMENT = 'Stream table for real-time delivery events from Kafka';

-- =====================================================
-- CREATE VIEWS FOR QUERYING
-- =====================================================

-- View for Orders
CREATE OR REPLACE VIEW SILVER.V_ORDERS_STREAM AS
SELECT
    -- Kafka metadata
    RECORD_METADATA:offset::NUMBER AS KAFKA_OFFSET,
    RECORD_METADATA:partition::NUMBER AS KAFKA_PARTITION,
    TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3) AS KAFKA_TIMESTAMP,

    -- Event data
    RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE,
    TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,

    -- Order data
    RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
    RECORD_CONTENT:customer_id::VARCHAR AS CUSTOMER_ID,
    RECORD_CONTENT:restaurant_id::INTEGER AS RESTAURANT_ID,
    RECORD_CONTENT:order_date::TIMESTAMP_TZ AS ORDER_DATE,
    RECORD_CONTENT:total_amount::NUMBER(10,2) AS TOTAL_AMOUNT,
    RECORD_CONTENT:status::VARCHAR AS STATUS,
    RECORD_CONTENT:payment_method::VARCHAR AS PAYMENT_METHOD,

    -- Processing flags
    INGESTED_AT,
    PROCESSED_TO_GOLD,
    BATCH_ID
FROM SILVER.ORDERS_STREAM_SLV;

-- View for Order Items
CREATE OR REPLACE VIEW SILVER.V_ORDER_ITEMS_STREAM AS
SELECT
    -- Kafka metadata
    RECORD_METADATA:offset::NUMBER AS KAFKA_OFFSET,
    RECORD_METADATA:partition::NUMBER AS KAFKA_PARTITION,
    TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3) AS KAFKA_TIMESTAMP,

    -- Event data
    RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE,
    TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,

    -- Order item data
    RECORD_CONTENT:order_item_id::VARCHAR AS ORDER_ITEM_ID,
    RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
    RECORD_CONTENT:menu_id::INTEGER AS MENU_ID,
    RECORD_CONTENT:quantity::INTEGER AS QUANTITY,
    RECORD_CONTENT:price::NUMBER(10,2) AS PRICE,
    RECORD_CONTENT:subtotal::NUMBER(10,2) AS SUBTOTAL,

    -- Processing flags
    INGESTED_AT,
    PROCESSED_TO_GOLD,
    BATCH_ID
FROM SILVER.ORDER_ITEMS_STREAM_SLV;

-- View for Delivery
CREATE OR REPLACE VIEW SILVER.V_DELIVERY_STREAM AS
SELECT
    -- Kafka metadata
    RECORD_METADATA:offset::NUMBER AS KAFKA_OFFSET,
    RECORD_METADATA:partition::NUMBER AS KAFKA_PARTITION,
    TO_TIMESTAMP(RECORD_METADATA:CreateTime::NUMBER, 3) AS KAFKA_TIMESTAMP,

    -- Event data
    RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE,
    TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,

    -- Delivery data
    RECORD_CONTENT:delivery_id::VARCHAR AS DELIVERY_ID,
    RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
    RECORD_CONTENT:delivery_agent_id::INTEGER AS DELIVERY_AGENT_ID,
    RECORD_CONTENT:delivery_status::VARCHAR AS DELIVERY_STATUS,
    RECORD_CONTENT:estimated_time::TIMESTAMP_TZ AS ESTIMATED_TIME,
    RECORD_CONTENT:customer_address_id::INTEGER AS CUSTOMER_ADDRESS_ID,
    RECORD_CONTENT:delivery_date::TIMESTAMP_TZ AS DELIVERY_DATE,
    RECORD_CONTENT:location::VARIANT AS LOCATION,

    -- Processing flags
    INGESTED_AT,
    PROCESSED_TO_GOLD,
    BATCH_ID
FROM SILVER.DELIVERY_STREAM_SLV;

-- =====================================================
-- CREATE SNOWFLAKE STREAMS (CDC)
-- =====================================================

-- Stream for Orders
CREATE OR REPLACE STREAM SILVER.STREAM_ORDERS_CHANGES
ON TABLE SILVER.ORDERS_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new order records for Gold layer processing';

-- Stream for Order Items
CREATE OR REPLACE STREAM SILVER.STREAM_ORDER_ITEMS_CHANGES
ON TABLE SILVER.ORDER_ITEMS_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new order item records for Gold layer processing';

-- Stream for Delivery
CREATE OR REPLACE STREAM SILVER.STREAM_DELIVERY_CHANGES
ON TABLE SILVER.DELIVERY_STREAM_SLV
APPEND_ONLY = TRUE
COMMENT = 'Captures new delivery records for Gold layer processing';

-- =====================================================
-- GRANT PERMISSIONS TO KAFKA ROLE
-- =====================================================

GRANT SELECT, INSERT ON TABLE SILVER.ORDERS_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;
GRANT SELECT, INSERT ON TABLE SILVER.ORDER_ITEMS_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;
GRANT SELECT, INSERT ON TABLE SILVER.DELIVERY_STREAM_SLV TO ROLE KAFKA_CONNECTOR_ROLE;

-- =====================================================
-- VERIFY SETUP
-- =====================================================

-- Check tables
SHOW TABLES LIKE '%STREAM%' IN SCHEMA SILVER;

-- Check streams
SHOW STREAMS IN SCHEMA SILVER;

-- View table structure
DESC TABLE SILVER.ORDERS_STREAM_SLV;
DESC TABLE SILVER.ORDER_ITEMS_STREAM_SLV;
DESC TABLE SILVER.DELIVERY_STREAM_SLV;

-- =====================================================
-- STREAMING PROCEDURES - SILVER TO GOLD
-- =====================================================
USE ROLE ACCOUNTADMIN;
USE DATABASE SWIGGY;
USE WAREHOUSE ADHOC_WH;

-- =====================================================
-- PROCEDURE 1: ORDERS STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_ORDERS_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_ROWS_UPDATED INTEGER;
    V_ROWS_PROCESSED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();

    -- Check if stream has data
    IF (SYSTEM$STREAM_HAS_DATA('SWIGGY.SILVER.STREAM_ORDERS_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;

    -- Process orders from stream
    MERGE INTO GOLD.FACT_ORDER AS TGT
    USING (
        SELECT
            RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
            RECORD_CONTENT:customer_id::VARCHAR AS CUSTOMER_ID,
            RECORD_CONTENT:restaurant_id::INTEGER AS RESTAURANT_ID,
            RECORD_CONTENT:order_date::TIMESTAMP_TZ AS ORDER_DATE,
            RECORD_CONTENT:total_amount::NUMBER(10,2) AS TOTAL_AMOUNT,
            RECORD_CONTENT:status::VARCHAR AS STATUS,
            RECORD_CONTENT:payment_method::VARCHAR AS PAYMENT_METHOD,
            TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,
            RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE
        FROM SILVER.STREAM_ORDERS_CHANGES
        WHERE RECORD_CONTENT:order_id IS NOT NULL
          AND RECORD_CONTENT:event_type::VARCHAR IN ('ORDER_CREATED', 'ORDER_UPDATED')
    ) AS SRC
    ON TGT.ORDER_ID = SRC.ORDER_ID

    -- Update existing orders (status changes)
    WHEN MATCHED AND TGT.CURRENT_STATUS != SRC.STATUS THEN
        UPDATE SET
            CURRENT_STATUS = SRC.STATUS,
            TOTAL_AMOUNT = SRC.TOTAL_AMOUNT,
            STATUS_UPDATED_AT = SRC.EVENT_TIMESTAMP,
            BATCH_ID = :V_BATCH_ID

    -- Insert new orders
    WHEN NOT MATCHED THEN
        INSERT (
            ORDER_ID, CUSTOMER_ID, RESTAURANT_ID, ORDER_DATE,
            TOTAL_AMOUNT, CURRENT_STATUS, INITIAL_STATUS,
            PAYMENT_METHOD, STATUS_UPDATED_AT, BATCH_ID, CREATED_AT
        )
        VALUES (
            SRC.ORDER_ID, SRC.CUSTOMER_ID, SRC.RESTAURANT_ID,
            SRC.ORDER_DATE, SRC.TOTAL_AMOUNT, SRC.STATUS, SRC.STATUS,
            SRC.PAYMENT_METHOD, SRC.EVENT_TIMESTAMP, :V_BATCH_ID,
            CURRENT_TIMESTAMP()
        );

    V_ROWS_PROCESSED := SQLROWCOUNT;

    -- Log status changes to history
    INSERT INTO GOLD.FACT_ORDER_STATUS_HISTORY (
        ORDER_ID, OLD_STATUS, NEW_STATUS, STATUS_CHANGED_AT, BATCH_ID
    )
    SELECT
        TGT.ORDER_ID,
        TGT.CURRENT_STATUS AS OLD_STATUS,
        SRC.STATUS AS NEW_STATUS,
        SRC.EVENT_TIMESTAMP,
        :V_BATCH_ID
    FROM (
        SELECT
            RECORD_CONTENT:order_id::INTEGER AS ORDER_ID,
            RECORD_CONTENT:status::VARCHAR AS STATUS,
            TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,
            RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE
        FROM SILVER.STREAM_ORDERS_CHANGES
        WHERE RECORD_CONTENT:event_type::VARCHAR = 'ORDER_UPDATED'
    ) SRC
    INNER JOIN GOLD.FACT_ORDER TGT ON TGT.ORDER_ID = SRC.ORDER_ID
    WHERE TGT.CURRENT_STATUS != SRC.STATUS;

    -- Mark stream records as processed
    UPDATE SILVER.ORDERS_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE RECORD_CONTENT:order_id::INTEGER IN (
        SELECT RECORD_CONTENT:order_id::INTEGER FROM SILVER.STREAM_ORDERS_CHANGES
    );

    V_END_TIME := CURRENT_TIMESTAMP();

    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_PROCESSED', V_ROWS_PROCESSED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );

EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- PROCEDURE 2: ORDER ITEMS STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_ORDER_ITEMS_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();

    IF (SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_ORDER_ITEMS_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;

    -- Insert new order items (append-only)
    INSERT INTO GOLD.FACT_ORDER_ITEM (
        ORDER_ITEM_ID, ORDER_ID, MENU_ID, QUANTITY,
        PRICE, SUBTOTAL, ORDER_TIMESTAMP, BATCH_ID, CREATED_AT
    )
    SELECT
        RECORD_CONTENT:order_item_id::VARCHAR AS ORDER_ITEM_ID,
        RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
        RECORD_CONTENT:menu_id::INTEGER AS MENU_ID,
        RECORD_CONTENT:quantity::INTEGER AS QUANTITY,
        RECORD_CONTENT:price::NUMBER(10,2) AS PRICE,
        RECORD_CONTENT:subtotal::NUMBER(10,2) AS SUBTOTAL,
        TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,
        :V_BATCH_ID,
        CURRENT_TIMESTAMP()
    FROM SILVER.STREAM_ORDER_ITEMS_CHANGES
    WHERE RECORD_CONTENT:order_item_id IS NOT NULL
      AND RECORD_CONTENT:event_type::VARCHAR = 'ITEM_ADDED'
      AND NOT EXISTS (
          SELECT 1 FROM GOLD.FACT_ORDER_ITEM TGT
          WHERE TGT.ORDER_ITEM_ID = RECORD_CONTENT:order_item_id::VARCHAR
      );

    V_ROWS_INSERTED := SQLROWCOUNT;

    -- Mark as processed
    UPDATE SILVER.ORDER_ITEMS_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE RECORD_CONTENT:order_item_id::VARCHAR IN (
        SELECT RECORD_CONTENT:order_item_id::VARCHAR FROM SILVER.STREAM_ORDER_ITEMS_CHANGES
    );

    V_END_TIME := CURRENT_TIMESTAMP();

    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_INSERTED', V_ROWS_INSERTED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );

EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- PROCEDURE 3: DELIVERY STREAM TO GOLD
-- =====================================================
CREATE OR REPLACE PROCEDURE GOLD.SP_DELIVERY_STREAM_TO_GOLD()
RETURNS VARIANT
LANGUAGE SQL
AS
$$
DECLARE
    V_BATCH_ID STRING;
    V_ROWS_INSERTED INTEGER;
    V_ROWS_UPDATED INTEGER;
    V_ROWS_PROCESSED INTEGER;
    V_START_TIME TIMESTAMP_TZ;
    V_END_TIME TIMESTAMP_TZ;
BEGIN
    V_BATCH_ID := 'STREAM_' || UUID_STRING();
    V_START_TIME := CURRENT_TIMESTAMP();

    IF (SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_DELIVERY_CHANGES') = FALSE) THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'SKIPPED',
            'MESSAGE', 'No new data in stream',
            'BATCH_ID', V_BATCH_ID
        );
    END IF;

    -- Process delivery events
    MERGE INTO GOLD.FACT_DELIVERY AS TGT
    USING (
        SELECT
            RECORD_CONTENT:delivery_id::VARCHAR AS DELIVERY_ID,
            RECORD_CONTENT:order_id::VARCHAR AS ORDER_ID,
            RECORD_CONTENT:delivery_agent_id::INTEGER AS DELIVERY_AGENT_ID,
            RECORD_CONTENT:customer_address_id::INTEGER AS CUSTOMER_ADDRESS_ID,
            RECORD_CONTENT:delivery_status::VARCHAR AS DELIVERY_STATUS,
            RECORD_CONTENT:estimated_time::TIMESTAMP_TZ AS ESTIMATED_TIME,
            RECORD_CONTENT:delivery_date::TIMESTAMP_TZ AS DELIVERY_DATE,
            TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,
            RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE
        FROM SILVER.STREAM_DELIVERY_CHANGES
        WHERE RECORD_CONTENT:delivery_id IS NOT NULL
    ) AS SRC
    ON TGT.DELIVERY_ID = SRC.DELIVERY_ID

    -- Update delivery status
    WHEN MATCHED AND TGT.CURRENT_STATUS != SRC.DELIVERY_STATUS THEN
        UPDATE SET
            CURRENT_STATUS = SRC.DELIVERY_STATUS,
            DELIVERY_DATE = SRC.DELIVERY_DATE,
            STATUS_UPDATED_AT = SRC.EVENT_TIMESTAMP,
            BATCH_ID = :V_BATCH_ID

    -- Insert new delivery
    WHEN NOT MATCHED THEN
        INSERT (
            DELIVERY_ID, ORDER_ID, DELIVERY_AGENT_ID, CUSTOMER_ADDRESS_ID,
            CURRENT_STATUS, INITIAL_STATUS, ESTIMATED_TIME, DELIVERY_DATE,
            STATUS_UPDATED_AT, BATCH_ID, CREATED_AT
        )
        VALUES (
            SRC.DELIVERY_ID, SRC.ORDER_ID, SRC.DELIVERY_AGENT_ID,
            SRC.CUSTOMER_ADDRESS_ID, SRC.DELIVERY_STATUS, SRC.DELIVERY_STATUS,
            SRC.ESTIMATED_TIME, SRC.DELIVERY_DATE, SRC.EVENT_TIMESTAMP,
            :V_BATCH_ID, CURRENT_TIMESTAMP()
        );

    V_ROWS_PROCESSED := SQLROWCOUNT;

    -- Log status changes
    INSERT INTO GOLD.FACT_DELIVERY_STATUS_HISTORY (
        DELIVERY_ID, OLD_STATUS, NEW_STATUS, STATUS_CHANGED_AT, BATCH_ID
    )
    SELECT
        TGT.DELIVERY_ID,
        TGT.CURRENT_STATUS AS OLD_STATUS,
        SRC.DELIVERY_STATUS AS NEW_STATUS,
        SRC.EVENT_TIMESTAMP,
        :V_BATCH_ID
    FROM (
        SELECT
            RECORD_CONTENT:delivery_id::INTEGER AS DELIVERY_ID,
            RECORD_CONTENT:delivery_status::VARCHAR AS DELIVERY_STATUS,
            TO_TIMESTAMP_TZ(RECORD_CONTENT:event_timestamp::STRING) AS EVENT_TIMESTAMP,
            RECORD_CONTENT:event_type::VARCHAR AS EVENT_TYPE
        FROM SILVER.STREAM_DELIVERY_CHANGES
        WHERE RECORD_CONTENT:event_type::VARCHAR = 'STATUS_UPDATED'
    ) SRC
    INNER JOIN GOLD.FACT_DELIVERY TGT ON TGT.DELIVERY_ID = SRC.DELIVERY_ID
    WHERE TGT.CURRENT_STATUS != SRC.DELIVERY_STATUS;

    -- Mark as processed
    UPDATE SILVER.DELIVERY_STREAM_SLV
    SET PROCESSED_TO_GOLD = TRUE,
        BATCH_ID = :V_BATCH_ID
    WHERE RECORD_CONTENT:delivery_id::INTEGER IN (
        SELECT RECORD_CONTENT:delivery_id::INTEGER FROM SILVER.STREAM_DELIVERY_CHANGES
    );

    V_END_TIME := CURRENT_TIMESTAMP();

    RETURN OBJECT_CONSTRUCT(
        'STATUS', 'SUCCESS',
        'BATCH_ID', V_BATCH_ID,
        'ROWS_PROCESSED', V_ROWS_PROCESSED,
        'DURATION_SECONDS', DATEDIFF(SECOND, V_START_TIME, V_END_TIME)
    );

EXCEPTION
    WHEN OTHER THEN
        RETURN OBJECT_CONSTRUCT(
            'STATUS', 'FAILED',
            'ERROR', SQLERRM,
            'BATCH_ID', V_BATCH_ID
        );
END;
$$;

-- =====================================================
-- CREATE SNOWFLAKE TASKS
-- =====================================================

-- Task for Orders (every 5 minutes)
CREATE OR REPLACE TASK GOLD.TASK_ORDERS_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '5 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_ORDERS_CHANGES')
AS
CALL GOLD.SP_ORDERS_STREAM_TO_GOLD();

-- Task for Order Items (every 5 minutes)
CREATE OR REPLACE TASK GOLD.TASK_ORDER_ITEMS_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '5 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_ORDER_ITEMS_CHANGES')
AS
CALL GOLD.SP_ORDER_ITEMS_STREAM_TO_GOLD();

-- Task for Delivery (every 2 minutes - more frequent)
CREATE OR REPLACE TASK GOLD.TASK_DELIVERY_STREAM_TO_GOLD
    WAREHOUSE = ADHOC_WH
    SCHEDULE = '5 MINUTE'
    WHEN SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_DELIVERY_CHANGES')
AS
CALL GOLD.SP_DELIVERY_STREAM_TO_GOLD();

-- Resume all tasks
ALTER TASK GOLD.TASK_ORDERS_STREAM_TO_GOLD RESUME;
ALTER TASK GOLD.TASK_ORDER_ITEMS_STREAM_TO_GOLD RESUME;
ALTER TASK GOLD.TASK_DELIVERY_STREAM_TO_GOLD RESUME;

-- =====================================================
-- MONITORING QUERIES
-- =====================================================

-- Check stream status
SELECT
    'SILVER.STREAM_ORDERS_CHANGES' AS STREAM_NAME,
    SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_ORDERS_CHANGES') AS HAS_DATA
UNION ALL
SELECT
    'SILVER.STREAM_ORDER_ITEMS_CHANGES',
    SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_ORDER_ITEMS_CHANGES')
UNION ALL
SELECT
    'SILVER.STREAM_DELIVERY_CHANGES',
    SYSTEM$STREAM_HAS_DATA('SILVER.STREAM_DELIVERY_CHANGES');

-- Check recent data in streams
SELECT COUNT(*) AS ORDERS_COUNT FROM SILVER.STREAM_ORDERS_CHANGES;
SELECT COUNT(*) AS ORDER_ITEMS_COUNT FROM SILVER.STREAM_ORDER_ITEMS_CHANGES;
SELECT COUNT(*) AS DELIVERY_COUNT FROM SILVER.STREAM_DELIVERY_CHANGES;

-- View sample data using views
SELECT * FROM SILVER.V_ORDERS_STREAM LIMIT 10;
SELECT * FROM SILVER.V_ORDER_ITEMS_STREAM LIMIT 10;
SELECT * FROM SILVER.V_DELIVERY_STREAM LIMIT 10;

SELECT * FROM GOLD.FACT_DELIVERY WHERE BATCH_ID LIKE 'STREAM%';
SELECT * FROM GOLD.FACT_ORDER_ITEM WHERE BATCH_ID LIKE 'STREAM%';
SELECT * FROM GOLD.FACT_ORDER WHERE BATCH_ID LIKE 'STREAM%';


